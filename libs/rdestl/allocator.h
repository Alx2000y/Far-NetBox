#ifndef RDESTL_ALLOCATOR_H
#define RDESTL_ALLOCATOR_H

#include <stdlib.h>

#ifdef USE_DLMALLOC
#include <dlmalloc/malloc-2.8.6.h>
#endif

#ifdef USE_DLMALLOC
#define nb_malloc(size) dlmalloc(size)
#define nb_calloc(count,size) dlcalloc(count,size)
#define nb_realloc(ptr,size) dlrealloc(ptr,size)
#define nb_free(ptr) dlfree(ptr)
#else
#define nb_malloc(size) ::malloc(size)
#define nb_calloc(count,size) ::calloc(count,size)
#define nb_realloc(ptr,size) ::realloc(ptr,size)
#define nb_free(ptr) ::free(ptr)
#endif

namespace rde
{

// CONCEPT!
class allocator
{
public:
	explicit allocator()	{}
	// Copy ctor generated by compiler.
	// allocator(const allocator &)
	~allocator() {}

	// Generated by compiler.
	//allocator & operator=(const allocator &)

	void * allocate(size_t bytes, int flags = 0);
	// Not supported for standard allocator for the time being.
	void * allocate_aligned(size_t bytes, size_t alignment, int flags = 0);
	void deallocate(void * ptr, size_t bytes);

private:
};

// True if lhs can free memory allocated by rhs and vice-versa.
inline bool operator==(const allocator & /*lhs*/, const allocator & /*rhs*/)
{
	return true;
}
inline bool operator!=(const allocator & lhs, const allocator & rhs)
{
	return !(lhs == rhs);
}

inline void * allocator::allocate(size_t bytes, int)
{
	// return operator new(bytes);
	return nb_malloc(bytes);
}

inline void allocator::deallocate(void * ptr, size_t)
{
	// operator delete(ptr);
	nb_free(ptr);
}

} // namespace rde

//-----------------------------------------------------------------------------
#endif // #ifndef RDESTL_ALLOCATOR_H
